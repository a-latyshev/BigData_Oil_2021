load "msh3" load "medit" load "gmsh" load "MUMPS_seq" load "tetgen" load "mshmet" load "mmg3d-v4.0"

real PROGRAM = clock();

real SQRT2=sqrt(2.0);
real ZERO = 1e-8;
string VALUES = "results/stresses_values.csv"; 
string RESULTS = "results/failure_criteria_results.csv";
string LOG = "results/result_log.txt";
string ERRORS = "results/errors.csv";
string TIME = "results/time.csv";
string MESH2D = "domain/Open_wellbore_in_rock_box_2D.msh";
string MESH3D = "domain/Open_wellbore_in_rock_box_3D.msh";
string CALLGMSH2D = "gmsh ./domain/Open_wellbore_in_rock_box.geo -2 -format msh2 -o " + MESH2D;
string CALLGMSH3D = "gmsh ./domain/Open_wellbore_in_rock_box.geo -3 -format msh2 -o " + MESH3D;

int INSIDE = 1;
//int BOTTOM = 2;
//int TOP = 3;
int OUTSIDE = 2;

real lambda, mu, E, nu, P, Rw;
real sig11, sig12, sig13, sig22, sig23, sig33;
real sigmaC, sigmaB, sigmaT, sigmaY;

real meshDensity;

int iters = 1;
bool makeAdaptation = false;

{
  ifstream input1("configs/parameters.txt");
  input1 >> E >> nu >> P >> sig11 >> sig12 >> sig13 >> sig22 >> sig23 >> sig33 >> sigmaC >> sigmaT >> sigmaY;

  ifstream input2("configs/geometry.txt");
  input2 >> Rw;

  ifstream input3("configs/mesh.txt");
  input3 >> meshDensity;
}

sigmaB = SQRT2 * sigmaC;

mu = E/(2*(1+nu));
lambda = E*nu/((1+nu)*(1-2*nu));

system("mkdir results");
system("mkdir results/visualization");

include "../include/InitializationSolution.edp";

macro epsilon(u1,u2,u3) [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/SQRT2, (dz(u1)+dx(u3))/SQRT2,(dy(u1)+dx(u2))/SQRT2] // End of macros (EOM)
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

macro s1() (N.x*sigma11 + N.y*sigma12 + N.z*sigma13) // EOM
macro s2() (N.x*sigma12 + N.y*sigma22 + N.z*sigma23) // EOM
macro s3() (N.x*sigma13 + N.y*sigma23 + N.z*sigma33) // EOM
macro sN() [s1,s2,s3] //EOM

macro Press() P*[N.x, N.y, N.z] // EOM

/* Initialization */ 
system(CALLGMSH3D);

real READMESH = clock();

mesh3 Th = gmshload3(MESH3D);
//medit("Domain",Th);
//mesh3 Th = gmshload3(MESH3D);
//Th = tetg(Th,switch="pYYAaQ");

READMESH = clock() - READMESH;


varf Lame([u1,u2,u3],[v1,v2,v3]) = 
  int3d(Th)(
    lambda*div(u1,u2,u3)*div(v1,v2,v3) 
    + 2.0*mu*(epsilon(u1,u2,u3)'*epsilon(v1,v2,v3)))
  ; 
  
varf vF([u1,u2,u3],[v1,v2,v3]) = 
  int2d(Th,OUTSIDE) (sN'*[v1,v2,v3])
  - int2d(Th,INSIDE) (Press'*[v1,v2,v3])
  ;

{
  fespace Ph(Th,P0);
  Ph h = hTriangle;
  ofstream fout(LOG);
  fout << "######################################### Configs #########################################" << endl;
  fout << " Number of Nodes on circles = " << meshDensity << "; " << endl;
  fout << "##############################################################################################" << endl;
  fout << "######################################### Parameters #########################################" << endl;
  fout << " E = " << E << " MPa; " << " nu = " << nu << "; " << " P = " << P << " MPa; " << " R = " << Rw << " cm; " << endl;
  fout << " sigma11 = " << sig11 << " MPa; " << " sigma12 = " << sig12 << " MPa; " << " sigma13 = " << sig13 << " MPa; " 
       << " sigma22 = " << sig22 << " MPa; " << " sigma23 = " << sig23 << " MPa; " << " sigma33 = " << sig33 << " MPa; " << endl;
  fout << "##############################################################################################" << endl;
  fout << endl;
  fout << "Mesh file (2D): " + MESH2D << endl;
  fout << "$$$$$$$$$$$$$$$$$$$$$$$$$$ Iteration # 0 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" << endl;
  fout << "Initialized (2D by GMSH, 3D by TetGen) : " << endl;
  fout << "Vertices: \t" << Th.nv << endl;
  fout << "Boundary elements: \t" << Th.nbe << endl;
  fout << "Tetrahedrons: \t" << Th.nt << endl;
  fout << "Minimal edge size: \t" << Th.hmin << endl;
  fout << "Maximum edge size: \t" << Th.hmax << endl;
  fout << "Minimal diameter: \t" << h[].min << endl;
  fout << "Maximum diameter: \t" << h[].max << endl;
  fout << endl;

  cout << "PH NDOF: " << Ph.ndof << endl;

}

while (iters == 1) {
  ++iters;

  real FESPACECREATING = clock();

  fespace Vh1(Th,P1);
  fespace Vh3(Th,[P1,P1,P1]);
  Vh3 [u1,u2,u3], [v1,v2,v3];
  Vh1 feSigma11, feSigma22, feSigma33, feSigma12, feSigma13, feSigma23, srr;
  Vh1 sigma11Error,sigma12Error,sigma13Error,sigma23Error,sigma22Error,sigma33Error;
  Vh1 sigma11h,sigma12h,sigma13h,sigma23h,sigma22h,sigma33h;
  Vh1 s11, s12, s13, s22, s23, s33;
  Vh1 ss11, ss12, ss13, ss22, ss23, ss33;

  FESPACECREATING = clock() - FESPACECREATING;

  cout << "VH1 NDOF: " << Vh1.ndof << endl;
  cout << "VH3 NDOF: " << Vh3.ndof << endl;
  /* Solving the Problem */

  real ASSEMBLING = clock();

  matrix MLame=Lame(Vh3,Vh3);
  set(MLame,solver=sparsesolver);
  real[int] F = vF(0,Vh3);

  ASSEMBLING = clock() - ASSEMBLING;

  real SOLVE = clock();

  u1[] = MLame^-1*F;
  u2[] = MLame^-1*F;
  u3[] = MLame^-1*F;

  SOLVE = clock() - SOLVE;

  /* For Calculating the Error */
  real ERRORS = clock();

  feSigma11 = lambda*div(u1,u2,u3) + 2.0*mu*dx(u1);
  feSigma22 = lambda*div(u1,u2,u3) + 2.0*mu*dy(u2);
  feSigma33 = lambda*div(u1,u2,u3) + 2.0*mu*dz(u3);
  feSigma12 = mu*(dy(u1) + dx(u2));
  feSigma13 = mu*(dz(u1) + dx(u3));
  feSigma23 = mu*(dy(u3) + dz(u2));
  srr = (feSigma11*x^2 + feSigma22*y^2 + 2*feSigma12*x*y)/(x^2 + y^2);

  s11 = sigma11 - feSigma11;
  s12 = sigma12 - feSigma12;
  s13 = sigma13 - feSigma13;
  s23 = sigma23 - feSigma23;
  s22 = sigma22 - feSigma22;
  s33 = sigma33 - feSigma33;
  ss11 = sigma11;
  ss22 = sigma22;
  ss33 = sigma33;
  ss12 = sigma12;
  ss13 = sigma13;
  ss23 = sigma23;
  sigma11Error = abs(s11);
  sigma22Error = abs(s22);
  sigma33Error = abs(s33);
  sigma12Error = abs(s12);
  sigma13Error = abs(s13);
  sigma23Error = abs(s23);
  sigma11h = abs(sigma11);
  sigma22h = abs(sigma22);
  sigma33h = abs(sigma33);
  sigma12h = abs(sigma12);
  sigma13h = abs(sigma13);
  sigma23h = abs(sigma23);
  real L2ErrorSigma11 = sqrt( int3d(Th)(s11^2) );
  real L2ErrorSigma12 = sqrt( int3d(Th)(s12^2) );
  real L2ErrorSigma13 = sqrt( int3d(Th)(s13^2) );
  real L2ErrorSigma22 = sqrt( int3d(Th)(s22^2) );
  real L2ErrorSigma23 = sqrt( int3d(Th)(s23^2) );
  real L2ErrorSigma33 = sqrt( int3d(Th)(s33^2) );
  real L2RelativeErrorSigma11 = ( int3d(Th)(ss11^2) > ZERO ) ? sqrt( int3d(Th)(s11^2) / int3d(Th)(ss11^2) ) : 0;
  real L2RelativeErrorSigma12 = ( int3d(Th)(ss12^2) > ZERO ) ? sqrt( int3d(Th)(s12^2) / int3d(Th)(ss12^2) ) : 0;
  real L2RelativeErrorSigma13 = ( int3d(Th)(ss13^2) > ZERO ) ? sqrt( int3d(Th)(s13^2) / int3d(Th)(ss13^2) ) : 0;
  real L2RelativeErrorSigma22 = ( int3d(Th)(ss22^2) > ZERO ) ? sqrt( int3d(Th)(s22^2) / int3d(Th)(ss22^2) ) : 0;
  real L2RelativeErrorSigma23 = ( int3d(Th)(ss23^2) > ZERO ) ? sqrt( int3d(Th)(s23^2) / int3d(Th)(ss23^2) ) : 0;
  real L2RelativeErrorSigma33 = ( int3d(Th)(ss33^2) > ZERO ) ? sqrt( int3d(Th)(s33^2) / int3d(Th)(ss33^2) ) : 0;
  real MAXABSRelativeErrorSigma11 = ( sigma11h[].max > ZERO ) ? ( sigma11Error[].max / sigma11h[].max ) : 0;
  real MAXABSRelativeErrorSigma12 = ( sigma12h[].max > ZERO ) ? ( sigma12Error[].max / sigma12h[].max ) : 0;
  real MAXABSRelativeErrorSigma13 = ( sigma13h[].max > ZERO ) ? ( sigma13Error[].max / sigma13h[].max ) : 0;
  real MAXABSRelativeErrorSigma22 = ( sigma22h[].max > ZERO ) ? ( sigma22Error[].max / sigma22h[].max ) : 0;
  real MAXABSRelativeErrorSigma23 = ( sigma23h[].max > ZERO ) ? ( sigma23Error[].max / sigma23h[].max ) : 0;
  real MAXABSRelativeErrorSigma33 = ( sigma33h[].max > ZERO ) ? ( sigma33Error[].max / sigma33h[].max ) : 0;

  {
    ofstream fout(LOG,append);
    fout << "Absolute error (max of |Analytic - Numerical|): \n" << endl;
    fout << "Signum11 \t = " << sigma11Error[].max << "\t MPa" << endl;
    fout << "Signum12 \t = " << sigma12Error[].max << "\t MPa" << endl;
    fout << "Signum13 \t = " << sigma13Error[].max << "\t MPa" << endl;
    fout << "Signum22 \t = " << sigma22Error[].max << "\t MPa" << endl;
    fout << "Signum23 \t = " << sigma23Error[].max << "\t MPa" << endl;
    fout << "Signum33 \t = " << sigma33Error[].max << "\t MPa" << endl;
    fout << endl;
    fout << "L2 Error of (Analytic - Numerical): \n" << endl;
    fout << "Signum11 \t = " << L2ErrorSigma11 << "\t MPa" << endl;
    fout << "Signum12 \t = " << L2ErrorSigma12 << "\t MPa" << endl;
    fout << "Signum13 \t = " << L2ErrorSigma13 << "\t MPa" << endl;
    fout << "Signum22 \t = " << L2ErrorSigma22 << "\t MPa" << endl;
    fout << "Signum23 \t = " << L2ErrorSigma23 << "\t MPa" << endl;
    fout << "Signum33 \t = " << L2ErrorSigma33 << "\t MPa" << endl;
    fout << endl;
    fout << "Max of |Analytic|: \n" << endl;
    fout << "Signum11 \t = " << sigma11h[].max << "\t MPa" << endl;
    fout << "Signum12 \t = " << sigma12h[].max << "\t MPa" << endl;
    fout << "Signum13 \t = " << sigma13h[].max << "\t MPa" << endl;
    fout << "Signum22 \t = " << sigma22h[].max << "\t MPa" << endl;
    fout << "Signum23 \t = " << sigma23h[].max << "\t MPa" << endl;
    fout << "Signum33 \t = " << sigma33h[].max << "\t MPa" << endl;
    fout << endl;
    fout << "Relative error (max of |Analytic - Numerical|)/(max of |Analytic|): \n" << endl;
    fout << "Signum11 \t = " << MAXABSRelativeErrorSigma11 * 100 << " %" << endl;
    fout << "Signum12 \t = " << MAXABSRelativeErrorSigma12 * 100 << " %" << endl;
    fout << "Signum13 \t = " << MAXABSRelativeErrorSigma13 * 100 << " %" << endl;
    fout << "Signum22 \t = " << MAXABSRelativeErrorSigma22 * 100 << " %" << endl;
    fout << "Signum23 \t = " << MAXABSRelativeErrorSigma23 * 100 << " %" << endl;
    fout << "Signum33 \t = " << MAXABSRelativeErrorSigma33 * 100 << " %" << endl;
    fout << endl;
    fout << "L2 Relative error (L2 of (Analytic - Numerical))/(L2 of (Analytic)): \n" << endl;
    fout << "Signum11 \t = " << L2RelativeErrorSigma11 * 100 << " %" << endl;
    fout << "Signum12 \t = " << L2RelativeErrorSigma12 * 100 << " %" << endl;
    fout << "Signum13 \t = " << L2RelativeErrorSigma13 * 100 << " %" << endl;
    fout << "Signum22 \t = " << L2RelativeErrorSigma22 * 100 << " %" << endl;
    fout << "Signum23 \t = " << L2RelativeErrorSigma23 * 100 << " %" << endl;
    fout << "Signum33 \t = " << L2RelativeErrorSigma33 * 100 << " %" << endl;
    fout << endl;
    fout << "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" << endl;
    fout << endl;
    /*ofstream fout2(ERRORS,append);
    fout2 << "\nFreeFem ERRORS;"
    fout2 << sigma11Error[].max << ";" << endl;
    fout2 << sigma12Error[].max << ";" << endl;
    fout2 << sigma13Error[].max << ";" << endl;
    fout2 << sigma22Error[].max << ";" << endl;
    fout2 << sigma23Error[].max << ";" << endl;
    fout2 << sigma33Error[].max << ";" << endl;
    fout << endl;
    fout << "L2 Error of (Analytic - Numerical): \n" << endl;
    fout << "Signum11 \t = " << L2ErrorSigma11 << "\t MPa" << endl;
    fout << "Signum12 \t = " << L2ErrorSigma12 << "\t MPa" << endl;
    fout << "Signum13 \t = " << L2ErrorSigma13 << "\t MPa" << endl;
    fout << "Signum22 \t = " << L2ErrorSigma22 << "\t MPa" << endl;
    fout << "Signum23 \t = " << L2ErrorSigma23 << "\t MPa" << endl;
    fout << "Signum33 \t = " << L2ErrorSigma33 << "\t MPa" << endl;
    fout << endl;
    fout << "Max of |Analytic|: \n" << endl;
    fout << "Signum11 \t = " << sigma11h[].max << "\t MPa" << endl;
    fout << "Signum12 \t = " << sigma12h[].max << "\t MPa" << endl;
    fout << "Signum13 \t = " << sigma13h[].max << "\t MPa" << endl;
    fout << "Signum22 \t = " << sigma22h[].max << "\t MPa" << endl;
    fout << "Signum23 \t = " << sigma23h[].max << "\t MPa" << endl;
    fout << "Signum33 \t = " << sigma33h[].max << "\t MPa" << endl;
    fout << endl;
    fout << "Relative error (max of |Analytic - Numerical|)/(max of |Analytic|): \n" << endl;
    fout << "Signum11 \t = " << MAXABSRelativeErrorSigma11 * 100 << " %" << endl;
    fout << "Signum12 \t = " << MAXABSRelativeErrorSigma12 * 100 << " %" << endl;
    fout << "Signum13 \t = " << MAXABSRelativeErrorSigma13 * 100 << " %" << endl;
    fout << "Signum22 \t = " << MAXABSRelativeErrorSigma22 * 100 << " %" << endl;
    fout << "Signum23 \t = " << MAXABSRelativeErrorSigma23 * 100 << " %" << endl;
    fout << "Signum33 \t = " << MAXABSRelativeErrorSigma33 * 100 << " %" << endl;
    fout << endl;
    fout << "L2 Relative error (L2 of (Analytic - Numerical))/(L2 of (Analytic)): \n" << endl;
    fout << "Signum11 \t = " << L2RelativeErrorSigma11 * 100 << " %" << endl;
    fout << "Signum12 \t = " << L2RelativeErrorSigma12 * 100 << " %" << endl;
    fout << "Signum13 \t = " << L2RelativeErrorSigma13 * 100 << " %" << endl;
    fout << "Signum22 \t = " << L2RelativeErrorSigma22 * 100 << " %" << endl;
    fout << "Signum23 \t = " << L2RelativeErrorSigma23 * 100 << " %" << endl;
    fout << "Signum33 \t = " << L2RelativeErrorSigma33 * 100 << " %" << endl;
    fout << endl;*/
  }

  ERRORS = clock() - ERRORS;

  if (makeAdaptation) {
    mesh3 ThAdapt = Th;
    fespace Vh1Adapt(ThAdapt,P1);
    fespace Vh6Adapt(ThAdapt,[P1,P1,P1,P1,P1,P1]);
    Vh1Adapt met;
    Vh6Adapt [mA11,mA21,mA22,mA31,mA32,mA33];
    [mA11,mA21,mA22,mA31,mA32,mA33] = [feSigma11,feSigma12,feSigma22,feSigma13,feSigma23,feSigma33];
    met[] = mshmet(ThAdapt,[mA11,mA21,mA22,mA31,mA32,mA33],normalization=1,aniso=0,nbregul=1,err=0.01,hmin=Th.hmin,hmax=Th.hmax); /* Metric generation on new mesh */
    
    //ThAdapt = mmg3d(ThAdapt,metric=met[],opt="-m 2000"); /* Adaptation new 3D mesh */
    ThAdapt=tetgreconstruction(ThAdapt,switch="rYYaAQ",sizeofvolume=met*met*met/6.0);

    {
      fespace Ph(ThAdapt,P0);
      Ph h = hTriangle;
      ofstream fout(LOG,append);
      fout << "$$$$$$$$$$$$$$$$$$$$$$$$$$ Iteration # " + iters + " $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" << endl;
      fout << "Adapted mesh after TetGen" << endl;
      fout << "Tetrahedrons now: \t" << ThAdapt.nt << endl;

      fout << "Vertices: \t" << ThAdapt.nv << endl;
      fout << "Boundary elements: \t" << ThAdapt.nbe << endl;
      fout << "Minimal edge size: \t" << ThAdapt.hmin << endl;
      fout << "Maximum edge size: \t" << ThAdapt.hmax << endl;
      fout << "Minimal diameter: \t" << h[].min << endl;
      fout << "Maximum diameter: \t" << h[].max << endl;
      fout << endl;
      fout << "met.min = \t" <<  met[].min << "\t met.max = \t" << met[].max << "\t met[].n = \t" << met[].n << endl; 
      fout << endl;
    }
    Th = ThAdapt;
  }

  real FAILURECRITSANDOTHER = clock();

  if (iters == 2) {
    system("mkdir results");
    system("mkdir results/visualization");

    include "../include/FailureCriterionsModule.edp";
    {
      ofstream fout(VALUES);
      fout << "#;x;y;z;Sigma11;Sigma12;Sigma13;Sigma22;Sigma23;Sigma33;" << endl; 
      for (int i = 0; i < N; ++i) {
        fout << i << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << ";" 
             << feSigma11[][i] << ";" << feSigma12[][i] << ";" << feSigma13[][i] << ";" << feSigma22[][i] << ";" << feSigma23[][i] << ";" << feSigma33[][i] << ";" << endl;
      }
    }   
    { 
      ofstream fout(RESULTS);
      fout << "Criterion;max[LHS] - RHS;max[LHS] / RHS - 1;Dimensionless coordinates of the maximum: x; y; z" << endl; 

      real max = findMax(fieldMTS[],N)[0];
      real i = findMax(fieldMTS[],N)[1];
      fout << "Maximum tensile stress;" << max << ";" << max / sigmaT << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << endl;

      max = findMax(fieldMSS[],N)[0];
      i = findMax(fieldMSS[],N)[1];
      fout << "Maximum shear stress;" << max << ";" << max / sigmaY << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << endl;

      max = findMax(fieldMohrCoulomb[],N)[0];
      i = findMax(fieldMohrCoulomb[],N)[1];
      fout << "Mohr-Coulomb;" << max << ";" << max / sigmaT << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << endl;

      max = findMax(fieldDruckerPrager[],N)[0];
      i = findMax(fieldDruckerPrager[],N)[1];
      fout << "Drucker-Prager;" << max << ";" << max / K << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << endl;

      max = findMax(fieldParabolicDruckerPrager[],N)[0];
      i = findMax(fieldParabolicDruckerPrager[],N)[1];
      fout << "Drucker-Prager (parabolic);" << max << ";" << max / KP << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << endl;

      max = findMax(fieldWillamWarnke[],N)[0];
      i = findMax(fieldWillamWarnke[],N)[1];
      fout << "Willam-Warnke;" << max << ";" << max / sigmaC << ";" << Th(i).x << ";" << Th(i).y << ";" << Th(i).z << endl;
    }
    load "iovtk"
    savevtk("results/visualization/MTS.vtk",Th,fieldMTS);
    savevtk("results/visualization/MSS.vtk",Th,fieldMSS);
    savevtk("results/visualization/MohrCoulomb.vtk",Th,fieldMohrCoulomb);
    savevtk("results/visualization/DruckerPrager.vtk",Th,fieldDruckerPrager);
    savevtk("results/visualization/ParabolicDruckerPrager.vtk",Th,fieldParabolicDruckerPrager);
    savevtk("results/visualization/WillamWarnke.vtk",Th,fieldWillamWarnke);
    savevtk("results/visualization/stresses.vtk",Th,feSigma11,feSigma12,feSigma22,feSigma13,feSigma23,feSigma33);
    savevtk("results/visualization/sRR.vtk",Th,srr);
    savevtk("results/visualization/s11.vtk",Th,feSigma11);
    savevtk("results/visualization/s12.vtk",Th,feSigma12);
    savevtk("results/visualization/s22.vtk",Th,feSigma22);
    //savevtk("results/visualization/invariants.vtk",Th,fieldSigma1,fieldSigma2,fieldSigma3);

  }

  FAILURECRITSANDOTHER = clock() - FAILURECRITSANDOTHER;

  PROGRAM = clock() - PROGRAM;
  {
    ofstream fout(TIME, append);
    fout << "\nFreeFem++ TIME RESULTS (seconds);" << "READMESH;" << "ASSEMBLING;" << "SOLVE;" << "FAILURE CRITS AND OTHER;"<< "ERRORS;" << "PROGRAM" << endl;
    fout << ";" << READMESH << ";" << ASSEMBLING << ";" << SOLVE << ";" << FAILURECRITSANDOTHER << ";" << ERRORS << ";" << PROGRAM << endl;
  }

}
  
